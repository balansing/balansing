# BalanSiNG: Fast and Scalable Balanced Signed Network Generator Following Real-world Properties

This repository contains codes and datasets used in the following paper submitted to KDD 2019.
* BalanSiNG: Fast and Scalable Balanced Signed Network Generator Following Real-world Properties, KDD'19, Anchorage, Alaska, USA

## Overview
How can we efficiently generate large-scale signed networks following real-world properties?
In signed networks, relations between nodes are represented as positive and negative edges.
These signed networks have spurred great attention in data mining  communities, and many researchers have been engaged in developing meaningful applications on signed networks.
However, our understanding of signed network generation following realistic properties was immature.
Many models have been proposed for generating unsigned networks, but those models do not consider the desirable formation of signed edges at all.

In this paper, we propose `BalanSiNG`, a novel, scalable, and fully parallelizable method for generating large-scale signed networks following realistic properties.
We first identify a self-similar balanced structure observed from a real signed network, and then simulate the self-similarity via Kronecker product.
Furthermore, we propose noise and weight techniques to produce practical signed networks.
Then, we show that `BalanSiNG` efficiently produces signed edges fully in parallel.
Our experimental results demonstrate that `BalanSiNG` efficiently generates realistic signed networks satisfying various desired properties compared to its competitors.

## Datasets
The datasets used in this paper are avariable at this repository. 

## Usages
We provide two implementations for BalanSiNG based on `scala` with `spark` and `c++`.

### How to run scala code
This code is for


### How to run c++ code
The c++ code is located in `cpp` directory, and based on mex of matlab which allows users to easily analyze signed networks generated by `BalanSiNG` with various visual plots. 
You can check the demo of this code by typing the following commands in matlab:
```
run_demo
```
The parameters used in the demo are as follows:
* A seed stochastic adjacency matrix for positive edges, `P = [0.57, 0; 0, 0.05]`
* A seed stochastic adjacency matrix for negative edges: `M = [0, 0.19; 0.19, 0]`
    * The stochastic signed tensor is represented as `T = {+P, -M}`, and they are simply represented as `A = P + M`
* The target recursion depth, `L = 12`
* The number of edges, `E = 24186`
* The parameter for weight spltting, `alpha = 0.15`
* The parameter for noise, `gamma = 0.1`

You can obtain an adjacency list (e.g., `[{source, target, sign}]`) generated by `BalanSiNG` using `cpp/BalanSiNG.m` which provides an interface between matlab and `cpp/GenerateEdgesBalanSiNG.cpp` generating signed edges based on `cpp`.
The input and output of `cpp/BalanSiNG.m` are as follows:

```matlab
function [X] = BalanSiNG(L, E, A, alpha, gamma)
%% Input
% L: target recursion depth (scalar), i.e., |V| = 2^L
% E: target number of edges (scalar)
% A: seed adjacency tensor (2 x 2 matrix), i.e., A = P + M
% gamma: parameter for noise (scalar)
% alpha: parameter for weight splitting (scalar)

%% Output
% X: signed adjacency list (E x 3 matrix), [source, target, sign]
end
```
